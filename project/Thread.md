### 生产者消费者问题

生产者消费者共享缓冲区，生产者向缓冲区中放数据，消费者从缓冲取中取数据，当缓冲区中被放满时，生产者线程就必须进入挂起状态，直到消费者从缓冲中取走数据时，生产者才能继续向缓冲区中存放数据，同样当缓冲取中没有数据时，消费者线程就必须进入挂起休眠状态，直到生产者向缓冲区中放入数据时，消费者才能被唤醒继续从缓冲区中取走数据。

生产者消费者问题，也称有限缓冲问题，是一个多线程同步问题的经典案例。

1. 单生产者单消费者队列（Single-producer , single-consumer Queue）
2. 多生产者多消费者队列（Multi-producer , Multi-consumer Queue）

- [C API](../old-Plan/TaskQueue.c)
- [C++ API](../old-Plan/TaskQueue.cpp)
- [java interface ](./java/MultiThreading.md)
### 哲学家问题

有五个哲学家绕着圆桌坐，每个哲学家面前有一盘面，两人之间有一支筷子，这样每个哲学家左右各有一支筷子。哲学家有2个状态，思考或者拿起筷子吃饭。如果哲学家拿到一只筷子，不能吃饭，直到拿到2只才能吃饭，并且一次只能拿起身边的一支筷子。一旦拿起便不会放下筷子直到把饭吃完，此时才把这双筷子放回原处。如果，很不幸地，每个哲学家拿起他或她左边的筷子，那么就没有人可以吃到饭了。

哲学家进餐问题是一个多线程运用的经典例子，涉及到线程同步/互斥，临界区访问问题以及死锁问题。

至少采用2~3种解决方案。


### 线程池

频繁的进行进程的创建与销毁将带来很多开销。不但如此，进程间频繁的切换也将减低 CPU 的利用率。
如果能复用之前创建的进程，而不是为每个并发任务创建一个进程，能有效降低进程创建与销毁的开销并减少进程间切换，从而减少对 CPU 资源的浪费。
虽然线程创建与销毁的代价小于进程创建与销毁，隶属同一进程的线程间切换的代价也小于进程间切换，但复用之前创建的线程，也能有效降低线程创建与销毁的开销并减少线程间切换，从而减少对 CPU 资源的浪费。

总而言之，为每个并发任务分别创建一个进程或线程这种做法，追求编写高性能程序的你可能难以接受这种做法。既然这样，不如来使用线程池来复用线程吧！

线程池就是让线程完成当前任务后继续等待分配给它的新任务！！！

是不是很简单？？？快来试试吧！！！

### 提高任务（选做）

还记得上面所说的吗？进程的创建与销毁比线程的创建与销毁的开销更大，那么能否使用进程池来复用进程呢？
快来试试吧！！！
